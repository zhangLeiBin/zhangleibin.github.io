<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[前端技术栈线路图]]></title>
    <url>%2F2018%2F07%2F15%2Ffullstack%2F</url>
    <content type="text"><![CDATA[阿里P7前端技术专家整理的前端进阶路线 该图片来源于第三方提供]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css初始化]]></title>
    <url>%2F2017%2F07%2F28%2Finitialize%2F</url>
    <content type="text"><![CDATA[我们知道，任何浏览器都会设置user agent stylesheet，通常大家 在做开发的时候，常常因为浏览器的样式不统一而产生一定的麻烦，浏览器的默认样式往往不能满足我们的预期，因此我们就需要重置浏览器样式下面则是本人开发中搜集的一些初始化样式，以及一些常用样式整理。。。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576不推荐改做法，因为会极大的增加浏览器的压力 *&#123; margin:0; padding:0 &#125;//推荐做法 /*禁止字体自动放大*/ body&#123; -webkit-text-size-adjust: 100% !important; text-size-adjust: 100% !important; -moz-text-size-adjust: 100% !important; &#125; body,dl,dd,p,h1~h6&#123;margin:0;padding:0&#125; h1~h6&#123;font-size:100%&#125;/*继承body字体大小*///根据屏幕大小改变字体 /*手机屏幕*/ @media screen and（max-width:768px）&#123; html&#123;font-size:15px&#125; &#125; /*平板屏幕*/ @media screen and（min-width:768px）and （max-width:992px）&#123; html&#123;font-size:20px&#125; &#125; /*电脑屏幕*/ @media screen and （min-width;992px）&#123; html&#123;font-size:25px&#125; &#125; body&#123;font-family:"Droid Sans Fallback","Heiti SC","Droid Sans","Helvetica","Helvetica Neue","sans-self";color:#555;background-color:#f7f7f7&#125; /*清除浮动*/.clearfix:after&#123;content:'';display:block;visibility:hidden;height:0;clear:both&#125;a:hover&#123;text-decoration:none&#125;ul,ol&#123;list-style:none;margin:0;padding:0&#125;/*图片自适应*/img&#123;max-width:100%;height:auto;&#125;/*如需默认样式可修改*/em,i&#123;font-style:normal&#125;/*除去焦点状态下的蓝色边框*/button,input,slect,textarea&#123;vertical-align:middle;outline:none&#125;/*修改占位词文字颜色*/input::-webket-input-placeholder,textarea::-webket-input-placeholder&#123;color:#ccc&#125;input:-ms-input-placeholder,textarea:-ms-input-placeholder &#123;color: #ccc;&#125;input::-webkit-input-placeholder,textarea::-webkit-input-placeholder &#123;color: #ccc;&#125;/*字体抗锯齿渲染平滑处理*/ -webkit-font-smoothing: // 主要有三个属性值 none: 无抗锯齿 subpixel-antialiased (default): 次像素平滑 常见于Mac OS和MacType For Windows antialiased: 灰度平滑 常用于Android和iOS等移动设备/*单行，溢出显示省略号*/ text-overflow: ellipsis; white-space:nowrap; overflow:hidden;/*多行，溢出显示省略号*/ overflow: hidden; text-overflow: ellipsis; display: -webkit-box; -webkit-line-clamp: 3; //n:超出该行数就隐藏 -webkit-box-orient: vertical; 后续继续补充中。。。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何使用npm发布自己的模块包]]></title>
    <url>%2F2017%2F04%2F20%2Fnpm%2F</url>
    <content type="text"><![CDATA[打开npm官网注册自己的账号 假设您对npm的相关使用已经相当熟悉 项目初始化1$ npm init 如图所示执行npm init根据提示填写相关初始化信息： 在npm资源库中注册用户（用户名、密码、邮箱）,也就是自己创建的npm的账户信息1$ npm adduser 如图所示 项目准备就绪，执行如下命令即可发布1$ npm publish 发布成功如图所示 发布成功后，登录npm官网即可查看，也可以在自己项目中安装自己的发布包，安装命令如下1$ npm install 发布包名称 5. 如果发布失败的话，常见403错误，检查自己的镜像或者检查自己的包名称是否已被占用 1$ npm config get registry （查看当前npm的镜像源是否为http://registry.npmjs.org/） 6. 如果不是http://registry.npmjs.org/，则需要做如下设置 1$ npm config set registry http://registry.npmjs.org/ 7. 删除发布包 12$ npm --force unpublish &lt;包名称&gt;$ npm --force unpublish &lt;包名称&gt;@版本号 //指定版本号删除 小注：（每次发布需修改package.json的版本号，修改规则如下） 语义版本号分为X.Y.Z三位，分别代表主版本号、次版本号和补丁版本号。 如果只是修复bug，需要更新Z位。 如果是新增了功能，但是向下兼容，需要更新Y位。 如果有大变动，向下不兼容，需要更新X位。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript学习笔记整理第2篇]]></title>
    <url>%2F2016%2F06%2F23%2FJavaScript%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86%E7%AC%AC2%E7%AF%87%2F</url>
    <content type="text"><![CDATA[关于Javascript常见创建对象的几种方式以及原型链分析 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131//1.创建构造函数 function Person(name,age,sex) &#123; this.name=name; this.age=age; this.sex=sex; this.say=function () &#123; console.log('我饿了。我要吃饭'); &#125; &#125;//调用构造函数创建对象以及使用 var obj = new Person('jack',18,'男'); obj.say(); console.log(obj.name); console.dir(obj); console.dir(Person); //obj.constructor 获取实例对象的构造器（构造函数）//判断某个对象是否属于这种数据类型 console.log('obj.constructor === Person',obj.constructor === Person); console.log('obj.__proto__.constructor === Person',obj.__proto__.constructor === Person); console.log('obj.__proto__.constructor === Person.prototype.constructor');//2.工厂方式创建对象 function createObject(name,age) &#123; var obj = new Object(); obj.name=name; obj.age=age; return obj; &#125;//调用工厂方法 var obj1 = createObject('张三',18); console.log(obj1); /** *两种方式对比 * 共同点：都是函数，都可以创建对象，都可以传入参数 * * 区别 * 工厂模式： * 函数名小写、 * 内部有new、 * 有返回值、 * 直接调用函数就是创建对象 * 自定义构造函数： * 函数名大写、 * 内部无new、 * 没有返回值、 * this是当前对象 * *///使用prototype创建原型属性与方法，实现（数据共享，节省内存） /*方式一*/ function Student(name,age,sex) &#123; this.name=name; this.age=age; this.sex=sex; &#125; Student.prototype.height=188; Student.prototype.weight='55kg'; Student.prototype.eat=function () &#123; console.log(this.name+'饿了，要吃饭去'); &#125;; Student.prototype.isWillSwiming=true; var p1 = new Student('码云',15,'男'); p1.eat(); console.dir(Student) console.log(p1); /*方式二*/ function Student(name,age,sex) &#123; this.name=name; this.age=age; this.sex=sex; &#125; //简写弊端：无法查看构造器指向，需手动修改 Student.prototype=&#123; //手动修改构造器的指向 constructor:Student, height:100, weight:'55kg', version:1.0, eat:function () &#123; console.log('该吃饭了'); &#125;, study:function () &#123; console.log('该学习了'); &#125;, swiming:function () &#123; console.log('该游泳了') &#125; &#125;; var stu = new Student("刘亦菲",18,'女') console.dir(Student) console.dir(stu)原型链总结 /** * 构造函数内部有自己的原型对象（protoptype） * 原型对象的构造器（constructor）指向自己的构造函数 * 实例对象内部有自己的原型（__proto__）指向的构造器（contructor）函数 * * * 实例对象先从自身寻找属性，如果找到就返回，如果没找到就从原型对象里边寻找，如果原型对象里也没有就直接报错了，整个寻找过程此时就形成了原型链 * * * 实例对象使用的属性或者方法，先在实例中查找，找到了则直接使用，找不到，去实例对象的_proto_指向构造函数的原型对象prototype中找，找到了则使用，找不到就报错 * 原型链：实例对象与原型对象之间的关系是通过原型（__proto__）来联系的，这种关系叫做原型链 * 实例对象与构造函数之间没有直接上的关系 * 构造函数中的this与原型对象中的this都是实例对象 * * * 原型??? * 实例对象中有__proto__这个属性，叫原型，也是一个对象，不是标准的属性 * 构造函数中有prototype这个属性，叫原型，也是一个对象，是标准的属性 * __proto__也可以叫原型对象 * prototype可以叫做原型对象 * * * 实例对象的__proto__和构造函数中的prototype相等 * 又因为实例对象是通过构造函数来创建的，构造函数中有原型对象prototype * 实例对象的__proto__指向了构造函数的原型对象prototype * * */]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript学习笔记整理第1篇]]></title>
    <url>%2F2016%2F06%2F21%2FJavaScript%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86%E7%AC%AC1%E7%AF%87%2F</url>
    <content type="text"><![CDATA[Javascript中的数据类型与基本语法规则 12345678910111213141516171819202122232425262728293031323334基本类型（值类型） Undefined Null Boolean Number String复杂类型（引用类型） Object Array Date RegExp Function内置对象： Global Math类型检测： typeof instanceof Object.prototype.toString.call()值类型与引用类型在内存中的存储方式 值类型按值存储（在栈中存储） 引用类型按引用存储 （地址在栈中存储，对象在堆中存储）作用域：使用范围 全局变量：声明的变量使用var，就是全局变量，全局变量可在任何位置使用 局部变量：在函数内部定义的变量，就是局部变量，外界无法使用 块级作用域（一对大括号就是一个块级作用域,在这块区域中定义的变量，只能在这个区域中使用，但是js在这个块级作用域中定义的变量，外面也可以使用，说明：js没有块级作用域） 扩展： 隐式全局变量：声明的变量没有var，就叫隐式全局变量 全局变量不能被删除，但是隐式全局变量可以被删除 预解析：在解析代码之前12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667 变量声明提前：把变量提前到当前所在的作用域的最上面 函数声明提前：提前到当前所在的作用域的最上面 * 注意： * 变量的提升只会在当前的作用域提升，提升到当前作用域的最前边 * 函数的变量只会提升到函数的作用域中的最前边 * 预解析会分段（多对的script标签中函数重名，预解析不会冲突） * 预解析的过程其实就是把函数的声明和变量的声明提前 * 变量的声明总是在函数的声明的最上边***** 案例一 ***** console.log(a);//猜想此处输出undefined？？？ function a() &#123; console.log('aaaaa'); var a=10;//变量a会被提升到作用域的最前边，所以说上边猜想输出undefined &#125; var a=11; console.log(a)//输出11 /** * 解析以上a的猜想结果为什么是[Function: a]，而不是a * 等效于如下 * var a; * function a()&#123;console.log('aaaaa');&#125; * console.log(a);//此处变量a与函数a同名，所以此处输出的是函数a * a=11; * console.log(a); * * */ ***** 案例二 *****abc();console.log(c); //输出9console.log(b); //输出9console.log(a); //报错：Uncaught ReferenceError: a is not definedfunction abc() &#123; var a=b=c=9; console.log(a) //9 console.log(b) //9 console.log(c) //9&#125;/** * 解释如下，等同于 * var b; var c; function abc() &#123; var a=b=c=9; var a; a=9; //局部变量 //b,c都为隐式全局变量，变量作用域为全局 b=9; c=9; console.log(a) //9 console.log(b) //9 console.log(c) //9 &#125; abc(); console.log(c); //输出9 console.log(b); //输出9 console.log(a); //局部变量，外部访问不到所以报错， * * */ 后续继续补充中。。。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用hexo搭建个人博客]]></title>
    <url>%2F2016%2F05%2F09%2Fhexo%2F</url>
    <content type="text"><![CDATA[关于如何使用hexo管理个人博客相关简介 Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>个人</tag>
      </tags>
  </entry>
</search>
